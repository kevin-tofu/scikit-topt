

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Optimization Algorithms in Density-Based Topology Optimization &mdash; scikit-topt 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://kevin-tofu.github.io/scikit-topt/optimization.html" />
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=938c9ccc"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="api.html" />
    <link rel="prev" title="Topology Optimization Algorithm Overview" href="theory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            scikit-topt
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Content</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Topology Optimization Algorithm Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimization Algorithms in Density-Based Topology Optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#optimality-criteria">Optimality Criteria</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#optimality-criteria-method-oc">Optimality Criteria Method (OC)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#advantages">Advantages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disadvantages">Disadvantages</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modified-optimality-criteria-moc-variants">Modified Optimality Criteria (MOC) Variants</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#log-space-update-method">1. Log-space Update Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-space-update-method">2. Linear-Space Update Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#log-space-lagrangian-method">Log-space Lagrangian Method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Log-space Lagrangian Method</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">scikit-topt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Optimization Algorithms in Density-Based Topology Optimization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/optimization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="optimization-algorithms-in-density-based-topology-optimization">
<h1>Optimization Algorithms in Density-Based Topology Optimization<a class="headerlink" href="#optimization-algorithms-in-density-based-topology-optimization" title="Link to this heading"></a></h1>
<p>Density-based topology optimization relies on continuous design variables to represent material distribution, and various optimization algorithms have been developed to update these densities effectively.</p>
<p>One of the most widely used methods is the <strong>Optimality Criteria (OC) method</strong>, which updates the density based on a closed-form expression derived from the Karush-Kuhn-Tucker (KKT) conditions. The OC method is simple to implement and provides fast convergence in many structural problems. It typically uses a multiplicative update rule that enforces a volume constraint while improving the compliance.</p>
<p>Another approach is the <strong>Modified Optimality Criteria (MOC)</strong> method, which extends the OC framework by incorporating additional strategies for handling constraints, improving stability, or enhancing convergence. For example, some MOC variants integrate projection and filtering directly into the update step or apply move limits and continuation schemes to control intermediate densities more robustly.</p>
<p>In addition to these, gradient-based methods using standard optimization libraries (e.g., MMA: Method of Moving Asymptotes) are also popular in density-based formulations, particularly when dealing with multiple constraints or noncompliance objectives.</p>
<p>Each of these methods offers different trade-offs in terms of implementation complexity, convergence speed, and robustness. The choice of optimization algorithm can significantly affect the quality and performance of the final design.</p>
<section id="optimality-criteria">
<h2>Optimality Criteria<a class="headerlink" href="#optimality-criteria" title="Link to this heading"></a></h2>
<section id="optimality-criteria-method-oc">
<h3>Optimality Criteria Method (OC)<a class="headerlink" href="#optimality-criteria-method-oc" title="Link to this heading"></a></h3>
<p>The Optimality Criteria (OC) method is a widely used algorithm in density-based topology optimization due to its simplicity and effectiveness. It provides a closed-form update rule for the design variables based on the optimality conditions derived from the Lagrangian of the problem.</p>
<p>Assume the goal is to minimize compliance <span class="math notranslate nohighlight">\(C(\rho)\)</span> subject to a volume constraint:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_{\rho} \quad C(\rho) = \mathbf{f}^T \mathbf{u}(\rho) \\
\text{subject to} \quad \sum_e \rho_e v_e \leq V_{\text{max}}, \quad \rho_{\text{min}} \leq \rho_e \leq 1\end{split}\]</div>
<p>The KKT conditions yield an optimality criterion involving the derivative of the objective function and a Lagrange multiplier <span class="math notranslate nohighlight">\(\lambda\)</span>. Based on this, the OC method defines the update rule for each element <span class="math notranslate nohighlight">\(e\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\rho_e^{(t+1)} = \text{clip}\left(
\rho_e^{(t)} \cdot \left( \frac{-\partial C / \partial \rho_e}{\lambda} \right)^{\eta},\
\rho_{\text{min}},\ 1
\right)\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\partial C / \partial \rho_e\)</span> is the sensitivity of compliance with respect to the design variable,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda\)</span> is chosen to satisfy the volume constraint (e.g., by bisection),</p></li>
<li><p><span class="math notranslate nohighlight">\(\eta\)</span> is a numerical damping or scaling factor (commonly <span class="math notranslate nohighlight">\(\eta = 1\)</span>),</p></li>
<li><p><cite>clip</cite> ensures the updated value stays within allowable bounds.</p></li>
</ul>
<p>The OC update rule is applied iteratively, and move limits may also be enforced to restrict the change in <span class="math notranslate nohighlight">\(\rho_e\)</span> between iterations.</p>
<section id="advantages">
<h4>Advantages<a class="headerlink" href="#advantages" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Simplicity</strong>: Easy to implement and understand.</p></li>
<li><p><strong>Efficiency</strong>: Fast convergence in practice for compliance minimization.</p></li>
<li><p><strong>No gradient solver needed</strong>: Only objective sensitivities are required, not the full gradient descent machinery.</p></li>
</ul>
</section>
<section id="disadvantages">
<h4>Disadvantages<a class="headerlink" href="#disadvantages" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Not general-purpose</strong>: Hard to extend to problems with multiple constraints or noncompliance objectives.</p></li>
<li><p><strong>Heuristic parameters</strong>: Requires tuning of parameters like damping factor, move limits.</p></li>
<li><p><strong>Volume constraint enforcement</strong>: Inexact unless a Lagrange multiplier search is properly implemented.</p></li>
<li><p><strong>Limited to multiplicative updates</strong>: Cannot easily incorporate modern optimization strategies (e.g., trust regions or line search).</p></li>
</ul>
<p>Despite its limitations, the OC method remains popular for compliance-based problems, especially when a quick and robust heuristic method is desired for early prototyping or academic demonstration.</p>
</section>
</section>
</section>
<section id="modified-optimality-criteria-moc-variants">
<h2>Modified Optimality Criteria (MOC) Variants<a class="headerlink" href="#modified-optimality-criteria-moc-variants" title="Link to this heading"></a></h2>
<p>In density-based topology optimization, the Modified Optimality Criteria (MOC) method can be implemented in several ways. I implemented two variants: a log-space update and a direct additive update. These differ in how they incorporate sensitivity information and handle volume constraints.</p>
<section id="log-space-update-method">
<h3>1. Log-space Update Method<a class="headerlink" href="#log-space-update-method" title="Link to this heading"></a></h3>
<p>This method modifies the OC update by applying it in <strong>log-space</strong>. Instead of directly updating the density <span class="math notranslate nohighlight">\(\rho\)</span>, it updates <span class="math notranslate nohighlight">\(\log \rho\)</span>, promoting better numerical stability and capturing multiplicative behavior.</p>
<p>The Lagrangian gradient <span class="math notranslate nohighlight">\(dL\)</span> is computed as the sum of the compliance sensitivity <span class="math notranslate nohighlight">\(dC\)</span> and a volume penalty term <span class="math notranslate nohighlight">\(\lambda_v\)</span>. The update is then applied in log-space:</p>
<div class="math notranslate nohighlight">
\[\log \rho^{(t+1)} = \log \rho^{(t)} + \eta \cdot \log \left( \frac{-dC}{\lambda_v} \right)\]</div>
<p>The updated density is then recovered via exponentiation:</p>
<div class="math notranslate nohighlight">
\[\rho^{(t+1)} = \rho^{(t)} \cdot \left( \frac{-dC}{\lambda_v} \right)^{\eta}\]</div>
<p>Here:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho^{(t)}\)</span> is the current density field,</p></li>
<li><p><span class="math notranslate nohighlight">\(dC\)</span> is the sensitivity of the compliance with respect to density,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda_v\)</span> is the derivative of the volume penalty,</p></li>
<li><p><span class="math notranslate nohighlight">\(\eta\)</span> is a step size or learning rate.</p></li>
</ul>
<p>This approach improves numerical stability and ensures that the density remains positive throughout the optimization process. Importantly, this means the optimization behaves <strong>multiplicatively</strong> rather than additively.</p>
<p>In this multiplicative regime, using a simple linear average to smooth the dual variable <span class="math notranslate nohighlight">\(\lambda_v\)</span> can lead to instability or a misrepresentation of the underlying dynamics. Instead, the <strong>Exponential Moving Average (EMA)</strong> is more appropriate because:</p>
<ul class="simple">
<li><p>EMA applies a <strong>multiplicative-style memory</strong>, giving more weight to recent changes while still preserving the trend of past updates.</p></li>
<li><p>It provides a <strong>smooth yet responsive</strong> estimate of the dual variable, crucial for stable convergence.</p></li>
<li><p>It avoids sharp oscillations that may occur when <span class="math notranslate nohighlight">\(\lambda_v\)</span> changes abruptly, which could cause large exponential shifts in the density update.</p></li>
</ul>
<p>The EMA of the dual variable is computed as:</p>
<div class="math notranslate nohighlight">
\[\lambda_v^{(t)} = \lambda_\text{decay} \cdot \lambda_v^{(t-1)} + (1 - \lambda_\text{decay}) \mu_{p} \cdot \hat{\lambda}_v^{(t)}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\lambda}_v^{(t)}\)</span> is the current value (e.g., based on volume constraint violation) and <span class="math notranslate nohighlight">\(\lambda_\text{decay} \in (0, 1]\)</span> is the smoothing factor.</p>
<p>Since MOC operates in a <strong>logarithmic or ratio-based update regime</strong>, EMA naturally complements this behavior by ensuring the dual variable evolves in a similarly smooth and proportional manner.</p>
<p>The objective function and the original constraint remain unchanged in the formulation:</p>
<p>However, in the implementation of MOC with EMA, the control of the dual variable <span class="math notranslate nohighlight">\(\lambda_v^{(t)}\)</span> is based on a <strong>relative (ratio-based) constraint violation</strong>, rather than an absolute difference.</p>
<p><strong>Advantages</strong>:</p>
<ul class="simple">
<li><p>Efficient in-place update suitable for large-scale problems.</p></li>
<li><p>Ensures positivity of design variables automatically.</p></li>
<li><p>Straightforward to implement using standard vector operations.</p></li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul class="simple">
<li><p>Requires careful tuning of <span class="math notranslate nohighlight">\(\eta\)</span> and <span class="math notranslate nohighlight">\(\lambda_v\)</span>.</p></li>
<li><p>Does not enforce volume constraints exactly—relies on penalty balancing.</p></li>
<li><p>Convergence behavior may vary depending on the problem and filter.</p></li>
</ul>
</section>
<section id="linear-space-update-method">
<h3>2. Linear-Space Update Method<a class="headerlink" href="#linear-space-update-method" title="Link to this heading"></a></h3>
<p>This variant formulates the update as an explicit increment <span class="math notranslate nohighlight">\(\Delta \rho\)</span> added to the current density. The update is defined as:</p>
<div class="math notranslate nohighlight">
\[\rho^{(t+1)} = \rho^{(t)} + \Delta \rho\]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[\Delta \rho = -\eta \cdot (dC + \lambda_v)\]</div>
<p>This form is structurally simpler and better suited for integration with additional constraint handling mechanisms. The update increment <span class="math notranslate nohighlight">\(\Delta \rho\)</span> may be further clipped to enforce move limits or bound constraints.</p>
<p><strong>Advantages</strong>:</p>
<ul class="simple">
<li><p>Direct control over the update magnitude.</p></li>
<li><p>Easier to incorporate projection, filtering, or move limits.</p></li>
<li><p>Simple to interpret and modify in algorithmic experiments.</p></li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul class="simple">
<li><p>Can violate positivity if not carefully bounded.</p></li>
<li><p>Volume constraint is only approximately satisfied unless post-processing is added.</p></li>
<li><p>Requires stabilization strategies (e.g., clipping or damping) for robust performance.</p></li>
</ul>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h3>
<p>Both update strategies aim to descend along the objective gradient while respecting volume constraints and maintaining stability. The choice depends on implementation goals:</p>
<ul class="simple">
<li><p>Use the log-space update when prioritizing positivity and multiplicative structure.</p></li>
<li><p>Use the additive update when flexibility, constraint control, or custom damping is desired.</p></li>
</ul>
</section>
</section>
<section id="log-space-lagrangian-method">
<h2>Log-space Lagrangian Method<a class="headerlink" href="#log-space-lagrangian-method" title="Link to this heading"></a></h2>
<section id="id1">
<h3>Log-space Lagrangian Method<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>This method is a variant of the Modified Optimality Criteria (MOC) approach that performs density updates in <strong>log-space</strong> rather than directly in the physical domain. The goal is to improve numerical stability and ensure that the updated density field remains strictly positive.</p>
<p>Instead of updating the density <span class="math notranslate nohighlight">\(\rho\)</span> directly, the update is applied to its logarithm <span class="math notranslate nohighlight">\(\log \rho\)</span>. This transforms the multiplicative update behavior into an additive one in log-space.</p>
<p>The method computes the Lagrangian gradient <span class="math notranslate nohighlight">\(dL\)</span> as the sum of the compliance sensitivity <span class="math notranslate nohighlight">\(dC\)</span> and the derivative of the volume penalty term <span class="math notranslate nohighlight">\(\lambda_v\)</span>. The update rule is:</p>
<div class="math notranslate nohighlight">
\[\log \rho^{(t+1)} = \log \rho^{(t)} - \eta \cdot (dC + \lambda_v)\]</div>
<p>The density is then recovered by exponentiation:</p>
<div class="math notranslate nohighlight">
\[\rho^{(t+1)} = \exp\left( \log \rho^{(t)} - \eta \cdot (dC + \lambda_v) \right)
            = \rho^{(t)} \cdot \exp\left( -\eta \cdot (dC + \lambda_v) \right)\]</div>
<p>Here:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\rho^{(t)}\)</span> is the current density at iteration <span class="math notranslate nohighlight">\(t\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(dC\)</span> is the derivative of compliance with respect to density,</p></li>
<li><p><span class="math notranslate nohighlight">\(\lambda_v\)</span> is the derivative of the volume constraint penalty,</p></li>
<li><p><span class="math notranslate nohighlight">\(\eta\)</span> is a scalar step size (analogous to a learning rate).</p></li>
</ul>
<p>Optional clipping is applied in log-space to limit excessive updates and preserve stability:</p>
<div class="math notranslate nohighlight">
\[\log \rho^{(t+1)} = \text{clip}\left( \log \rho^{(t+1)},\ \log \rho_{\min},\ \log \rho_{\max} \right)\]</div>
<p>Finally, move limits can also be enforced using:</p>
<div class="math notranslate nohighlight">
\[\rho^{(t+1)} = \text{clip}\left( \rho^{(t+1)},\ \rho^{(t)} - \Delta \rho_{\max},\ \rho^{(t)} + \Delta \rho_{\max} \right)\]</div>
<p><strong>Advantages</strong>:</p>
<ul class="simple">
<li><p>Naturally ensures <span class="math notranslate nohighlight">\(\rho &gt; 0\)</span> without additional constraints.</p></li>
<li><p>Suitable for in-place and vectorized computation in large-scale problems.</p></li>
<li><p>Converts multiplicative effects into additive updates, improving numerical robustness.</p></li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul class="simple">
<li><p>Sensitive to step size <span class="math notranslate nohighlight">\(\eta\)</span> and penalty weight <span class="math notranslate nohighlight">\(\lambda_v\)</span>.</p></li>
<li><p>Volume constraints are only enforced implicitly via penalty.</p></li>
<li><p>Requires careful initialization and parameter tuning to ensure convergence.</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="theory.html" class="btn btn-neutral float-left" title="Topology Optimization Algorithm Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Kohei Watanabe.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>